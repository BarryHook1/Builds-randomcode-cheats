; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_KernelBase@@3PEAXEA				; g_KernelBase
PUBLIC	?g_KernelSize@@3KA				; g_KernelSize
PUBLIC	ExPoolZeroingNativelySupported
_BSS	SEGMENT
?g_KernelBase@@3PEAXEA DQ 01H DUP (?)			; g_KernelBase
?g_KernelSize@@3KA DD 01H DUP (?)			; g_KernelSize
_BSS	ENDS
;	COMDAT ExPoolZeroingNativelySupported
_BSS	SEGMENT
ExPoolZeroingNativelySupported DB 01H DUP (?)
_BSS	ENDS
PUBLIC	?ResolveRelativeAddress@@YAPEAXPEAXKK@Z		; ResolveRelativeAddress
PUBLIC	?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z		; PatternScan
PUBLIC	?GetKernelBase@@YAPEAXPEAK@Z			; GetKernelBase
PUBLIC	?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z		; ScanSection
PUBLIC	?LocatePiDDB@@YAEPEAPEAU_ERESOURCE@@PEAPEAU_RTL_AVL_TABLE@@@Z ; LocatePiDDB
PUBLIC	?ClearPIDB@@YAEXZ				; ClearPIDB
PUBLIC	??_C@_1BG@KCECJMBN@?$AAN?$AAt?$AAO?$AAp?$AAe?$AAn?$AAF?$AAi?$AAl?$AAe@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@JHLLJCE@H?$IN?$AN?L?L?L?L?h?L?L?L?LH?$IL?$AN?L?L?L?L3?$NL@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@GMBJBOIB@H?$IN?$AN?L?L?L?L?h?L?L?L?L?$DN?L?L?L?L?$AP?$ID?L?L?L?L@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_04NKLNNIHE@PAGE@FNODOBFM@			;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BI@MOFLKFBG@?$AAi?$AAq?$AAv?$AAw?$AA6?$AA4?$AAe?$AA?4?$AAs?$AAy?$AAs@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_RtlInitAnsiString:PROC
EXTRN	__imp_MmGetSystemRoutineAddress:PROC
EXTRN	__imp_ExAllocatePoolWithTag:PROC
EXTRN	__imp_ExFreePoolWithTag:PROC
EXTRN	__imp_ExAcquireResourceExclusiveLite:PROC
EXTRN	__imp_ExReleaseResourceLite:PROC
EXTRN	__imp_RtlDeleteElementGenericTableAvl:PROC
EXTRN	__imp_RtlLookupElementGenericTableAvl:PROC
EXTRN	__imp_RtlCompareString:PROC
EXTRN	__imp_RtlImageNtHeader:PROC
EXTRN	ZwQuerySystemInformation:PROC
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z DD imagerel $LN33
	DD	imagerel $LN33+56
	DD	imagerel $unwind$?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z DD imagerel $LN33+56
	DD	imagerel $LN33+137
	DD	imagerel $chain$0$?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z DD imagerel $LN33+137
	DD	imagerel $LN33+168
	DD	imagerel $chain$2$?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z DD imagerel $LN33+168
	DD	imagerel $LN33+186
	DD	imagerel $chain$3$?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetKernelBase@@YAPEAXPEAK@Z DD imagerel $LN47
	DD	imagerel $LN47+197
	DD	imagerel $unwind$?GetKernelBase@@YAPEAXPEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?GetKernelBase@@YAPEAXPEAK@Z DD imagerel $LN47+197
	DD	imagerel $LN47+371
	DD	imagerel $chain$0$?GetKernelBase@@YAPEAXPEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?GetKernelBase@@YAPEAXPEAK@Z DD imagerel $LN47+371
	DD	imagerel $LN47+412
	DD	imagerel $chain$1$?GetKernelBase@@YAPEAXPEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z DD imagerel $LN98
	DD	imagerel $LN98+51
	DD	imagerel $unwind$?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z DD imagerel $LN98+51
	DD	imagerel $LN98+581
	DD	imagerel $chain$3$?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z DD imagerel $LN98+581
	DD	imagerel $LN98+723
	DD	imagerel $chain$5$?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?LocatePiDDB@@YAEPEAPEAU_ERESOURCE@@PEAPEAU_RTL_AVL_TABLE@@@Z DD imagerel $LN11
	DD	imagerel $LN11+274
	DD	imagerel $unwind$?LocatePiDDB@@YAEPEAPEAU_ERESOURCE@@PEAPEAU_RTL_AVL_TABLE@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ClearPIDB@@YAEXZ DD imagerel $LN30
	DD	imagerel $LN30+185
	DD	imagerel $unwind$?ClearPIDB@@YAEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ClearPIDB@@YAEXZ DD imagerel $LN30+185
	DD	imagerel $LN30+326
	DD	imagerel $chain$0$?ClearPIDB@@YAEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ClearPIDB@@YAEXZ DD imagerel $LN30+326
	DD	imagerel $LN30+392
	DD	imagerel $chain$2$?ClearPIDB@@YAEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?ClearPIDB@@YAEXZ DD imagerel $LN30+392
	DD	imagerel $LN30+399
	DD	imagerel $chain$4$?ClearPIDB@@YAEXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?ClearPIDB@@YAEXZ DD imagerel $LN30+399
	DD	imagerel $LN30+410
	DD	imagerel $chain$5$?ClearPIDB@@YAEXZ
pdata	ENDS
;	COMDAT ??_C@_1BI@MOFLKFBG@?$AAi?$AAq?$AAv?$AAw?$AA6?$AA4?$AAe?$AA?4?$AAs?$AAy?$AAs@FNODOBFM@
text$s	SEGMENT
??_C@_1BI@MOFLKFBG@?$AAi?$AAq?$AAv?$AAw?$AA6?$AA4?$AAe?$AA?4?$AAs?$AAy?$AAs@FNODOBFM@ DB 'i'
	DB	00H, 'q', 00H, 'v', 00H, 'w', 00H, '6', 00H, '4', 00H, 'e', 00H
	DB	'.', 00H, 's', 00H, 'y', 00H, 's', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_04NKLNNIHE@PAGE@FNODOBFM@
text$s	SEGMENT
??_C@_04NKLNNIHE@PAGE@FNODOBFM@ DB 'PAGE', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@GMBJBOIB@H?$IN?$AN?L?L?L?L?h?L?L?L?L?$DN?L?L?L?L?$AP?$ID?L?L?L?L@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@GMBJBOIB@H?$IN?$AN?L?L?L?L?h?L?L?L?L?$DN?L?L?L?L?$AP?$ID?L?L?L?L@FNODOBFM@ DB 'H'
	DB	08dH, 0dH, 0ccH, 0ccH, 0ccH, 0ccH, 0e8H, 0ccH, 0ccH, 0ccH, 0ccH
	DB	'=', 0ccH, 0ccH, 0ccH, 0ccH, 0fH, 083H, 0ccH, 0ccH, 0ccH, 0ccH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@JHLLJCE@H?$IN?$AN?L?L?L?L?h?L?L?L?LH?$IL?$AN?L?L?L?L3?$NL@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@JHLLJCE@H?$IN?$AN?L?L?L?L?h?L?L?L?LH?$IL?$AN?L?L?L?L3?$NL@FNODOBFM@ DB 'H'
	DB	08dH, 0dH, 0ccH, 0ccH, 0ccH, 0ccH, 0e8H, 0ccH, 0ccH, 0ccH, 0ccH
	DB	'H', 08bH, 0dH, 0ccH, 0ccH, 0ccH, 0ccH, '3', 0dbH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BG@KCECJMBN@?$AAN?$AAt?$AAO?$AAp?$AAe?$AAn?$AAF?$AAi?$AAl?$AAe@FNODOBFM@
text$s	SEGMENT
??_C@_1BG@KCECJMBN@?$AAN?$AAt?$AAO?$AAp?$AAe?$AAn?$AAF?$AAi?$AAl?$AAe@FNODOBFM@ DB 'N'
	DB	00H, 't', 00H, 'O', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'F', 00H
	DB	'i', 00H, 'l', 00H, 'e', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?ClearPIDB@@YAEXZ DD 020022H
	DD	06001602H
	DD	imagerel $LN30
	DD	imagerel $LN30+185
	DD	imagerel $unwind$?ClearPIDB@@YAEXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?ClearPIDB@@YAEXZ DD 020022H
	DD	0187400H
	DD	imagerel $LN30
	DD	imagerel $LN30+185
	DD	imagerel $unwind$?ClearPIDB@@YAEXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ClearPIDB@@YAEXZ DD 040022H
	DD	06001602H
	DD	0187400H
	DD	imagerel $LN30
	DD	imagerel $LN30+185
	DD	imagerel $unwind$?ClearPIDB@@YAEXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ClearPIDB@@YAEXZ DD 040822H
	DD	06001602H
	DD	0187408H
	DD	imagerel $LN30
	DD	imagerel $LN30+185
	DD	imagerel $unwind$?ClearPIDB@@YAEXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ClearPIDB@@YAEXZ DD 030b02H
	DD	014010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?LocatePiDDB@@YAEPEAPEAU_ERESOURCE@@PEAPEAU_RTL_AVL_TABLE@@@Z DD 060c02H
	DD	060f1602H
	DD	0e340cH
	DD	07008b20cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z DD 080022H
	DD	0ce400H
	DD	014d400H
	DD	0135400H
	DD	0123400H
	DD	imagerel $LN98
	DD	imagerel $LN98+51
	DD	imagerel $unwind$?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z DD 0a2622H
	DD	06001607H
	DD	0ce426H
	DD	014d41aH
	DD	0135410H
	DD	0123408H
	DD	imagerel $LN98
	DD	imagerel $LN98+51
	DD	imagerel $unwind$?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z DD 070b02H
	DD	06001607H
	DD	0f007c20bH
	DD	07003c005H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?GetKernelBase@@YAPEAXPEAK@Z DD 020022H
	DD	06141602H
	DD	imagerel $LN47
	DD	imagerel $LN47+197
	DD	imagerel $unwind$?GetKernelBase@@YAPEAXPEAK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?GetKernelBase@@YAPEAXPEAK@Z DD 020522H
	DD	08e405H
	DD	imagerel $LN47
	DD	imagerel $LN47+197
	DD	imagerel $unwind$?GetKernelBase@@YAPEAXPEAK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetKernelBase@@YAPEAXPEAK@Z DD 080f02H
	DD	067e0602H
	DD	0b640fH
	DD	0a340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z DD 020022H
	DD	06001603H
	DD	imagerel $LN33
	DD	imagerel $LN33+56
	DD	imagerel $unwind$?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z DD 040022H
	DD	06001603H
	DD	027400H
	DD	imagerel $LN33
	DD	imagerel $LN33+56
	DD	imagerel $unwind$?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z DD 040522H
	DD	06001603H
	DD	027405H
	DD	imagerel $LN33
	DD	imagerel $LN33+56
	DD	imagerel $unwind$?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z DD 050c02H
	DD	04640cH
	DD	03340cH
	DD	0e00cH
xdata	ENDS
; Function compile flags: /Ogtp
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\ClearTraces\ClearPIDcache.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\km\wdm.h
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\ClearTraces\ClearPIDcache.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\km\wdm.h
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\ClearTraces\ClearPIDcache.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\km\wdm.h
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\ClearTraces\ClearPIDcache.cpp
;	COMDAT ?ClearPIDB@@YAEXZ
_TEXT	SEGMENT
PiDDBLockPtr_sig$1 = 48
DriverName$ = 48
PiDTablePtr_sig$2 = 72
lookupEntry$ = 96
PiDDBLockPtr$3 = 176
PiDTablePtr$4 = 184
?ClearPIDB@@YAEXZ PROC					; ClearPIDB, COMDAT

; 180  : BOOLEAN ClearPIDB() {

$LN30:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 144  : 	UCHAR PiDDBLockPtr_sig[] = "\x48\x8D\x0D\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\x48\x8B\x0D\xCC\xCC\xCC\xCC\x33\xDB";

  0000b	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR ??_C@_0BG@JHLLJCE@H?$IN?$AN?L?L?L?L?h?L?L?L?LH?$IL?$AN?L?L?L?L3?$NL@FNODOBFM@+16

; 145  : 	UCHAR PiDTablePtr_sig[] = "\x48\x8D\x0D\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\x3D\xCC\xCC\xCC\xCC\x0F\x83\xCC\xCC\xCC\xCC";
; 146  : 
; 147  : 	PVOID PiDDBLockPtr = NULL;
; 148  : 	if (!NT_SUCCESS(ScanSection("PAGE", PiDDBLockPtr_sig, 0xCC, sizeof(PiDDBLockPtr_sig) - 1, (&PiDDBLockPtr)))) {

  00011	49 8d 53 88	 lea	 rdx, QWORD PTR [r11-120]
  00015	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BG@JHLLJCE@H?$IN?$AN?L?L?L?L?h?L?L?L?LH?$IL?$AN?L?L?L?L3?$NL@FNODOBFM@
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04NKLNNIHE@PAGE@FNODOBFM@
  00023	89 44 24 40	 mov	 DWORD PTR PiDDBLockPtr_sig$1[rsp+16], eax
  00027	f2 0f 10 0d 10
	00 00 00	 movsd	 xmm1, QWORD PTR ??_C@_0BI@GMBJBOIB@H?$IN?$AN?L?L?L?L?h?L?L?L?L?$DN?L?L?L?L?$AP?$ID?L?L?L?L@FNODOBFM@+16
  0002f	33 db		 xor	 ebx, ebx
  00031	0f b7 05 14 00
	00 00		 movzx	 eax, WORD PTR ??_C@_0BG@JHLLJCE@H?$IN?$AN?L?L?L?L?h?L?L?L?LH?$IL?$AN?L?L?L?L3?$NL@FNODOBFM@+20
  00038	41 b0 cc	 mov	 r8b, 204		; 000000ccH
  0003b	0f 11 44 24 30	 movups	 XMMWORD PTR PiDDBLockPtr_sig$1[rsp], xmm0
  00040	66 89 44 24 44	 mov	 WORD PTR PiDDBLockPtr_sig$1[rsp+20], ax
  00045	49 8d 43 08	 lea	 rax, QWORD PTR [r11+8]
  00049	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BI@GMBJBOIB@H?$IN?$AN?L?L?L?L?h?L?L?L?L?$DN?L?L?L?L?$AP?$ID?L?L?L?L@FNODOBFM@
  00050	44 8d 4b 15	 lea	 r9d, QWORD PTR [rbx+21]
  00054	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  00058	f2 0f 11 4c 24
	58		 movsd	 QWORD PTR PiDTablePtr_sig$2[rsp+16], xmm1
  0005e	0f 11 44 24 48	 movups	 XMMWORD PTR PiDTablePtr_sig$2[rsp], xmm0
  00063	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00068	e8 00 00 00 00	 call	 ?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z ; ScanSection
  0006d	85 c0		 test	 eax, eax
  0006f	0f 88 1a 01 00
	00		 js	 $LN26@ClearPIDB

; 149  : 		return FALSE;
; 150  : 	}
; 151  : 
; 152  : 	RtlZeroMemory(PiDDBLockPtr_sig, sizeof(PiDDBLockPtr_sig) - 1);
; 153  : 
; 154  : 	PVOID PiDTablePtr = NULL;
; 155  : 	if (!NT_SUCCESS(ScanSection("PAGE", PiDTablePtr_sig, 0xCC, sizeof(PiDTablePtr_sig) - 1, (&PiDTablePtr)))) {

  00075	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR PiDTablePtr$4[rsp]
  0007d	48 89 9c 24 b8
	00 00 00	 mov	 QWORD PTR PiDTablePtr$4[rsp], rbx
  00085	44 8d 4b 17	 lea	 r9d, QWORD PTR [rbx+23]
  00089	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008e	41 b0 cc	 mov	 r8b, 204		; 000000ccH
  00091	48 8d 54 24 48	 lea	 rdx, QWORD PTR PiDTablePtr_sig$2[rsp]
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04NKLNNIHE@PAGE@FNODOBFM@
  0009d	e8 00 00 00 00	 call	 ?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z ; ScanSection
  000a2	85 c0		 test	 eax, eax
  000a4	0f 88 e5 00 00
	00		 js	 $LN26@ClearPIDB

; 156  : 		return FALSE;
; 157  : 	}
; 158  : 
; 159  : 	RtlZeroMemory(PiDTablePtr_sig, sizeof(PiDTablePtr_sig) - 1);
; 160  : 
; 161  : 
; 162  : 	UINT64 RealPtrPIDLock = NULL;
; 163  : 
; 164  : 	RealPtrPIDLock = (UINT64)g_KernelBase + (UINT64)PiDDBLockPtr;

  000aa	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?g_KernelBase@@3PEAXEA ; g_KernelBase
  000b1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR PiDDBLockPtr$3[rsp]
  000b9	48 89 bc 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rdi

; 185  : 	}
; 186  : 
; 187  : 	// build a lookup entry
; 188  : 
; 189  : 	PIDCacheobj lookupEntry;
; 190  : 
; 191  : 	// this should work :D
; 192  : 	UNICODE_STRING DriverName = RTL_CONSTANT_STRING(L"iqvw64e.sys"); // intel driver aka the one that kdmapper use.

  000c1	c7 44 24 30 16
	00 18 00	 mov	 DWORD PTR DriverName$[rsp], 1572886 ; 00180016H

; 13   : 	PVOID ResolvedAddr = (PVOID)(Instr + InstructionSize + RipOffset);

  000c9	48 63 44 11 03	 movsxd	 rax, DWORD PTR [rcx+rdx+3]
  000ce	48 8d 59 07	 lea	 rbx, QWORD PTR [rcx+7]

; 172  : 	RealPtrPIDTable = (UINT64)g_KernelBase + (UINT64)PiDTablePtr;

  000d2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR PiDTablePtr$4[rsp]

; 13   : 	PVOID ResolvedAddr = (PVOID)(Instr + InstructionSize + RipOffset);

  000da	48 03 da	 add	 rbx, rdx

; 172  : 	RealPtrPIDTable = (UINT64)g_KernelBase + (UINT64)PiDTablePtr;

  000dd	48 03 ca	 add	 rcx, rdx

; 13   : 	PVOID ResolvedAddr = (PVOID)(Instr + InstructionSize + RipOffset);

  000e0	48 03 d8	 add	 rbx, rax

; 185  : 	}
; 186  : 
; 187  : 	// build a lookup entry
; 188  : 
; 189  : 	PIDCacheobj lookupEntry;
; 190  : 
; 191  : 	// this should work :D
; 192  : 	UNICODE_STRING DriverName = RTL_CONSTANT_STRING(L"iqvw64e.sys"); // intel driver aka the one that kdmapper use.

  000e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1BI@MOFLKFBG@?$AAi?$AAq?$AAv?$AAw?$AA6?$AA4?$AAe?$AA?4?$AAs?$AAy?$AAs@FNODOBFM@

; 196  : 
; 197  : 	// aquire the ddb lock
; 198  : 	ExAcquireResourceExclusiveLite(PiDDBLock, TRUE);

  000ea	b2 01		 mov	 dl, 1
  000ec	48 89 44 24 38	 mov	 QWORD PTR DriverName$[rsp+8], rax
  000f1	0f 10 44 24 30	 movups	 xmm0, XMMWORD PTR DriverName$[rsp]

; 13   : 	PVOID ResolvedAddr = (PVOID)(Instr + InstructionSize + RipOffset);

  000f6	48 63 79 03	 movsxd	 rdi, DWORD PTR [rcx+3]
  000fa	48 03 f9	 add	 rdi, rcx

; 193  : 	// removed *DriverName no need for it
; 194  : 	lookupEntry.DriverName = DriverName;
; 195  : 	lookupEntry.TimeDateStamp = 0x5284EAC3; // intel_driver TimeStamp.

  000fd	c7 84 24 80 00
	00 00 c3 ea 84
	52		 mov	 DWORD PTR lookupEntry$[rsp+32], 1384442563 ; 5284eac3H

; 196  : 
; 197  : 	// aquire the ddb lock
; 198  : 	ExAcquireResourceExclusiveLite(PiDDBLock, TRUE);

  00108	48 8b cb	 mov	 rcx, rbx
  0010b	0f 11 44 24 70	 movups	 XMMWORD PTR lookupEntry$[rsp+16], xmm0
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAcquireResourceExclusiveLite

; 199  : 
; 200  : 	// search our entry in the table
; 201  : 
; 202  : 	// maybe something will bsod here.
; 203  : 	PIDCacheobj* pFoundEntry = (PIDCacheobj*)RtlLookupElementGenericTableAvl(PiDDBCacheTable, &lookupEntry);

  00116	48 8d 54 24 60	 lea	 rdx, QWORD PTR lookupEntry$[rsp]
  0011b	48 8d 4f 07	 lea	 rcx, QWORD PTR [rdi+7]
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlLookupElementGenericTableAvl

; 204  : 	if (pFoundEntry == NULL)

  00125	48 85 c0	 test	 rax, rax
  00128	75 1c		 jne	 SHORT $LN3@ClearPIDB

; 205  : 	{
; 206  : 		// release the ddb resource lock
; 207  : 		ExReleaseResourceLite(PiDDBLock);

  0012a	48 8b cb	 mov	 rcx, rbx
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExReleaseResourceLite
  00133	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR [rsp+192]

; 208  : 		return FALSE;

  0013b	32 c0		 xor	 al, al

; 223  : }

  0013d	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  00144	5b		 pop	 rbx
  00145	c3		 ret	 0
$LN3@ClearPIDB:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\km\wdm.h

; 11807:     NextEntry = Entry->Flink;

  00146	48 8b 10	 mov	 rdx, QWORD PTR [rax]

; 11808:     PrevEntry = Entry->Blink;
; 11809:     if ((NextEntry->Blink != Entry) || (PrevEntry->Flink != Entry)) {

  00149	48 39 42 08	 cmp	 QWORD PTR [rdx+8], rax
  0014d	75 39		 jne	 SHORT $LN16@ClearPIDB
  0014f	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00153	49 39 00	 cmp	 QWORD PTR [r8], rax
  00156	75 30		 jne	 SHORT $LN16@ClearPIDB

; 11810:         FatalListEntryError((PVOID)PrevEntry,
; 11811:                             (PVOID)Entry,
; 11812:                             (PVOID)NextEntry);
; 11813:     }
; 11814: 
; 11815:     PrevEntry->Flink = NextEntry;

  00158	49 89 10	 mov	 QWORD PTR [r8], rdx
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\ClearTraces\ClearPIDcache.cpp

; 215  : 		RtlDeleteElementGenericTableAvl(PiDDBCacheTable, pFoundEntry);

  0015b	48 8d 4f 07	 lea	 rcx, QWORD PTR [rdi+7]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\km\wdm.h

; 11816:     NextEntry->Blink = PrevEntry;

  0015f	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\ClearTraces\ClearPIDcache.cpp

; 215  : 		RtlDeleteElementGenericTableAvl(PiDDBCacheTable, pFoundEntry);

  00163	48 8b d0	 mov	 rdx, rax
  00166	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlDeleteElementGenericTableAvl

; 216  : 
; 217  : 		// release the ddb resource lock
; 218  : 		ExReleaseResourceLite(PiDDBLock);

  0016c	48 8b cb	 mov	 rcx, rbx
  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExReleaseResourceLite
  00175	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR [rsp+192]

; 219  : 	}
; 220  : 
; 221  : 
; 222  : 	return TRUE;

  0017d	b0 01		 mov	 al, 1

; 223  : }

  0017f	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  00186	5b		 pop	 rbx
  00187	c3		 ret	 0
$LN16@ClearPIDB:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\km\wdm.h

; 11544:     __fastfail(Code);

  00188	b9 03 00 00 00	 mov	 ecx, 3
  0018d	cd 29		 int	 41			; 00000029H

; 11777:     RtlFailFast(FAST_FAIL_CORRUPT_LIST_ENTRY);

$LN26@ClearPIDB:
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\ClearTraces\ClearPIDcache.cpp

; 184  : 		return FALSE;

  0018f	32 c0		 xor	 al, al

; 223  : }

  00191	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  00198	5b		 pop	 rbx
  00199	c3		 ret	 0
$LN28@ClearPIDB:
?ClearPIDB@@YAEXZ ENDP					; ClearPIDB
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\ClearTraces\ClearPIDcache.cpp
;	COMDAT ?LocatePiDDB@@YAEPEAPEAU_ERESOURCE@@PEAPEAU_RTL_AVL_TABLE@@@Z
_TEXT	SEGMENT
PiDDBLockPtr_sig$ = 48
PiDTablePtr_sig$ = 72
lock$ = 112
table$ = 120
PiDDBLockPtr$ = 128
PiDTablePtr$ = 136
?LocatePiDDB@@YAEPEAPEAU_ERESOURCE@@PEAPEAU_RTL_AVL_TABLE@@@Z PROC ; LocatePiDDB, COMDAT

; 143  : {

$LN11:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  00007	57		 push	 rdi
  00008	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 144  : 	UCHAR PiDDBLockPtr_sig[] = "\x48\x8D\x0D\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\x48\x8B\x0D\xCC\xCC\xCC\xCC\x33\xDB";

  0000c	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR ??_C@_0BG@JHLLJCE@H?$IN?$AN?L?L?L?L?h?L?L?L?LH?$IL?$AN?L?L?L?L3?$NL@FNODOBFM@+16
  00012	48 8b da	 mov	 rbx, rdx
  00015	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BG@JHLLJCE@H?$IN?$AN?L?L?L?L?h?L?L?L?LH?$IL?$AN?L?L?L?L3?$NL@FNODOBFM@

; 145  : 	UCHAR PiDTablePtr_sig[] = "\x48\x8D\x0D\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\x3D\xCC\xCC\xCC\xCC\x0F\x83\xCC\xCC\xCC\xCC";
; 146  : 
; 147  : 	PVOID PiDDBLockPtr = NULL;
; 148  : 	if (!NT_SUCCESS(ScanSection("PAGE", PiDDBLockPtr_sig, 0xCC, sizeof(PiDDBLockPtr_sig) - 1, (&PiDDBLockPtr)))) {

  0001c	49 8d 53 c8	 lea	 rdx, QWORD PTR [r11-56]
  00020	89 44 24 40	 mov	 DWORD PTR PiDDBLockPtr_sig$[rsp+16], eax
  00024	f2 0f 10 0d 10
	00 00 00	 movsd	 xmm1, QWORD PTR ??_C@_0BI@GMBJBOIB@H?$IN?$AN?L?L?L?L?h?L?L?L?L?$DN?L?L?L?L?$AP?$ID?L?L?L?L@FNODOBFM@+16
  0002c	48 8b f9	 mov	 rdi, rcx
  0002f	0f b7 05 14 00
	00 00		 movzx	 eax, WORD PTR ??_C@_0BG@JHLLJCE@H?$IN?$AN?L?L?L?L?h?L?L?L?LH?$IL?$AN?L?L?L?L3?$NL@FNODOBFM@+20
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04NKLNNIHE@PAGE@FNODOBFM@
  0003d	0f 11 44 24 30	 movups	 XMMWORD PTR PiDDBLockPtr_sig$[rsp], xmm0
  00042	66 89 44 24 44	 mov	 WORD PTR PiDDBLockPtr_sig$[rsp+20], ax
  00047	49 8d 43 18	 lea	 rax, QWORD PTR [r11+24]
  0004b	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BI@GMBJBOIB@H?$IN?$AN?L?L?L?L?h?L?L?L?L?$DN?L?L?L?L?$AP?$ID?L?L?L?L@FNODOBFM@
  00052	41 b9 15 00 00
	00		 mov	 r9d, 21
  00058	41 b0 cc	 mov	 r8b, 204		; 000000ccH
  0005b	f2 0f 11 4c 24
	58		 movsd	 QWORD PTR PiDTablePtr_sig$[rsp+16], xmm1
  00061	0f 11 44 24 48	 movups	 XMMWORD PTR PiDTablePtr_sig$[rsp], xmm0
  00066	49 c7 43 18 00
	00 00 00	 mov	 QWORD PTR [r11+24], 0
  0006e	49 89 43 b8	 mov	 QWORD PTR [r11-72], rax
  00072	e8 00 00 00 00	 call	 ?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z ; ScanSection
  00077	85 c0		 test	 eax, eax
  00079	0f 88 86 00 00
	00		 js	 $LN9@LocatePiDD

; 149  : 		return FALSE;
; 150  : 	}
; 151  : 
; 152  : 	RtlZeroMemory(PiDDBLockPtr_sig, sizeof(PiDDBLockPtr_sig) - 1);
; 153  : 
; 154  : 	PVOID PiDTablePtr = NULL;
; 155  : 	if (!NT_SUCCESS(ScanSection("PAGE", PiDTablePtr_sig, 0xCC, sizeof(PiDTablePtr_sig) - 1, (&PiDTablePtr)))) {

  0007f	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR PiDTablePtr$[rsp]
  00087	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR PiDTablePtr$[rsp], 0
  00093	41 b9 17 00 00
	00		 mov	 r9d, 23
  00099	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009e	41 b0 cc	 mov	 r8b, 204		; 000000ccH
  000a1	48 8d 54 24 48	 lea	 rdx, QWORD PTR PiDTablePtr_sig$[rsp]
  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04NKLNNIHE@PAGE@FNODOBFM@
  000ad	e8 00 00 00 00	 call	 ?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z ; ScanSection
  000b2	85 c0		 test	 eax, eax
  000b4	78 4f		 js	 SHORT $LN9@LocatePiDD

; 156  : 		return FALSE;
; 157  : 	}
; 158  : 
; 159  : 	RtlZeroMemory(PiDTablePtr_sig, sizeof(PiDTablePtr_sig) - 1);
; 160  : 
; 161  : 
; 162  : 	UINT64 RealPtrPIDLock = NULL;
; 163  : 
; 164  : 	RealPtrPIDLock = (UINT64)g_KernelBase + (UINT64)PiDDBLockPtr;

  000b6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?g_KernelBase@@3PEAXEA ; g_KernelBase
  000bd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR PiDDBLockPtr$[rsp]

; 13   : 	PVOID ResolvedAddr = (PVOID)(Instr + InstructionSize + RipOffset);

  000c5	48 63 44 0a 03	 movsxd	 rax, DWORD PTR [rdx+rcx+3]
  000ca	48 03 ca	 add	 rcx, rdx
  000cd	48 83 c0 07	 add	 rax, 7
  000d1	48 03 c8	 add	 rcx, rax

; 165  : 
; 166  : 
; 167  : 	*lock = (PERESOURCE)ResolveRelativeAddress((PVOID)RealPtrPIDLock, 3, 7);

  000d4	48 89 0f	 mov	 QWORD PTR [rdi], rcx

; 168  : 
; 169  : 
; 170  : 	UINT64 RealPtrPIDTable = NULL;
; 171  : 
; 172  : 	RealPtrPIDTable = (UINT64)g_KernelBase + (UINT64)PiDTablePtr;

  000d7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?g_KernelBase@@3PEAXEA ; g_KernelBase
  000de	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR PiDTablePtr$[rsp]

; 13   : 	PVOID ResolvedAddr = (PVOID)(Instr + InstructionSize + RipOffset);

  000e6	48 63 44 0a 03	 movsxd	 rax, DWORD PTR [rdx+rcx+3]
  000eb	48 83 c1 07	 add	 rcx, 7
  000ef	48 03 ca	 add	 rcx, rdx
  000f2	48 03 c8	 add	 rcx, rax

; 173  : 
; 174  : 
; 175  : 	*table = (PRTL_AVL_TABLE)(ResolveRelativeAddress((PVOID)RealPtrPIDTable, 3, 7));
; 176  : 
; 177  : 	return TRUE;

  000f5	b0 01		 mov	 al, 1
  000f7	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 178  : }

  000fa	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  000ff	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00103	5f		 pop	 rdi
  00104	c3		 ret	 0
$LN9@LocatePiDD:
  00105	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0010a	32 c0		 xor	 al, al
  0010c	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00110	5f		 pop	 rdi
  00111	c3		 ret	 0
?LocatePiDDB@@YAEPEAPEAU_ERESOURCE@@PEAPEAU_RTL_AVL_TABLE@@@Z ENDP ; LocatePiDDB
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\ClearTraces\ClearPIDcache.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\km\Ntstrsafe.h
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\ClearTraces\ClearPIDcache.cpp
;	COMDAT ?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z
_TEXT	SEGMENT
bytes$1 = 32
routineName$2 = 40
s2$3 = 56
s1$4 = 72
section$ = 144
pattern$ = 152
wildcard$ = 160
len$ = 168
ppFound$ = 176
?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z PROC		; ScanSection, COMDAT

; 108  : {

$LN98:
  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 57		 push	 r15
  00007	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 109  : 	ASSERT(ppFound != NULL);
; 110  : 	if (ppFound == NULL)

  0000b	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR ppFound$[rsp], 0
  00014	49 8b f1	 mov	 rsi, r9
  00017	45 0f b6 f8	 movzx	 r15d, r8b
  0001b	48 8b fa	 mov	 rdi, rdx
  0001e	4c 8b e1	 mov	 r12, rcx
  00021	75 10		 jne	 SHORT $LN5@ScanSectio

; 111  : 		return STATUS_INVALID_PARAMETER;

  00023	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH

; 140  : }

  00028	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0002c	41 5f		 pop	 r15
  0002e	41 5c		 pop	 r12
  00030	5f		 pop	 rdi
  00031	5e		 pop	 rsi
  00032	c3		 ret	 0
$LN5@ScanSectio:
  00033	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx
  0003b	48 89 ac 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rbp

; 51   : 	ULONG bytes = 0;

  00043	33 ed		 xor	 ebp, ebp
  00045	4c 89 ac 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], r13

; 52   : 	PRTL_PROCESS_MODULES pMods = NULL;
; 53   : 	PVOID checkPtr = NULL;
; 54   : 	UNICODE_STRING routineName;
; 55   : 
; 56   : 	// Already found
; 57   : 	if (g_KernelBase != NULL)

  0004d	4c 8b 2d 00 00
	00 00		 mov	 r13, QWORD PTR ?g_KernelBase@@3PEAXEA ; g_KernelBase
  00054	4c 89 74 24 60	 mov	 QWORD PTR [rsp+96], r14

; 45   : }
; 46   : 
; 47   : 
; 48   : PVOID GetKernelBase(OUT PULONG pSize)
; 49   : {
; 50   : 	NTSTATUS status = STATUS_SUCCESS;
; 51   : 	ULONG bytes = 0;

  00059	89 6c 24 20	 mov	 DWORD PTR bytes$1[rsp], ebp

; 52   : 	PRTL_PROCESS_MODULES pMods = NULL;
; 53   : 	PVOID checkPtr = NULL;
; 54   : 	UNICODE_STRING routineName;
; 55   : 
; 56   : 	// Already found
; 57   : 	if (g_KernelBase != NULL)

  0005d	4d 85 ed	 test	 r13, r13
  00060	0f 85 30 01 00
	00		 jne	 $LN96@ScanSectio
  00066	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\km\Ntstrsafe.h

; 12651:         status = RtlStringLengthWorkerW(pszSrc, cchMax, &cchSrcLength);

  00069	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1BG@KCECJMBN@?$AAN?$AAt?$AAO?$AAp?$AAe?$AAn?$AAF?$AAi?$AAl?$AAe@FNODOBFM@
  00070	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  00075	49 8b c0	 mov	 rax, r8
  00078	0f 11 44 24 28	 movups	 XMMWORD PTR routineName$2[rsp], xmm0
  0007d	8b ca		 mov	 ecx, edx
  0007f	90		 npad	 1
$LL35@ScanSectio:

; 11856:     while (cchMax && (*psz != L'\0'))

  00080	66 39 28	 cmp	 WORD PTR [rax], bp
  00083	74 0c		 je	 SHORT $LN85@ScanSectio

; 11857:     {
; 11858:         psz++;

  00085	48 83 c0 02	 add	 rax, 2

; 11859:         cchMax--;

  00089	48 83 e9 01	 sub	 rcx, 1
  0008d	75 f1		 jne	 SHORT $LL35@ScanSectio

; 11860:     }
; 11861: 
; 11862:     if (cchMax == 0)
; 11863:     {
; 11864:         // the string is longer than cchMax
; 11865:         status = STATUS_INVALID_PARAMETER;
; 11866:     }
; 11867: 
; 11868:     if (pcchLength)
; 11869:     {
; 11870:         if (NT_SUCCESS(status))

  0008f	eb 19		 jmp	 SHORT $LN31@ScanSectio
$LN85@ScanSectio:

; 11871:         {
; 11872:             *pcchLength = cchOriginalMax - cchMax;

  00091	48 2b d1	 sub	 rdx, rcx

; 12665:                 DestinationString->Buffer = (PWSTR)pszSrc;

  00094	4c 89 44 24 30	 mov	 QWORD PTR routineName$2[rsp+8], r8
  00099	66 03 d2	 add	 dx, dx
  0009c	66 89 54 24 28	 mov	 WORD PTR routineName$2[rsp], dx
  000a1	66 83 c2 02	 add	 dx, 2
  000a5	66 89 54 24 2a	 mov	 WORD PTR routineName$2[rsp+2], dx
$LN31@ScanSectio:
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\ClearTraces\ClearPIDcache.cpp

; 66   : 	checkPtr = MmGetSystemRoutineAddress(&routineName);

  000aa	48 8d 4c 24 28	 lea	 rcx, QWORD PTR routineName$2[rsp]
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmGetSystemRoutineAddress
  000b5	48 8b d8	 mov	 rbx, rax

; 67   : 	if (checkPtr == NULL)

  000b8	48 85 c0	 test	 rax, rax
  000bb	0f 84 57 01 00
	00		 je	 $LN3@ScanSectio

; 68   : 		return NULL;
; 69   : 
; 70   : 	
; 71   : 	status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);

  000c1	44 8b 44 24 20	 mov	 r8d, DWORD PTR bytes$1[rsp]
  000c6	4c 8d 4c 24 20	 lea	 r9, QWORD PTR bytes$1[rsp]
  000cb	33 d2		 xor	 edx, edx
  000cd	8d 4a 0b	 lea	 ecx, QWORD PTR [rdx+11]
  000d0	e8 00 00 00 00	 call	 ZwQuerySystemInformation

; 72   : 
; 73   : 	if (bytes == 0)

  000d5	8b 44 24 20	 mov	 eax, DWORD PTR bytes$1[rsp]
  000d9	85 c0		 test	 eax, eax
  000db	0f 84 37 01 00
	00		 je	 $LN3@ScanSectio

; 74   : 		return NULL;
; 75   : 
; 76   : 	pMods = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, 0x454E4F45); // 'ENON'

  000e1	8b d0		 mov	 edx, eax
  000e3	33 c9		 xor	 ecx, ecx
  000e5	41 b8 45 4f 4e
	45		 mov	 r8d, 1162760005		; 454e4f45H
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag

; 77   : 	RtlZeroMemory(pMods, bytes);

  000f1	44 8b 44 24 20	 mov	 r8d, DWORD PTR bytes$1[rsp]
  000f6	33 d2		 xor	 edx, edx
  000f8	48 8b c8	 mov	 rcx, rax
  000fb	4c 8b f0	 mov	 r14, rax
  000fe	e8 00 00 00 00	 call	 memset

; 78   : 
; 79   : 	status = ZwQuerySystemInformation(SystemModuleInformation, pMods, bytes, &bytes);

  00103	44 8b 44 24 20	 mov	 r8d, DWORD PTR bytes$1[rsp]
  00108	4c 8d 4c 24 20	 lea	 r9, QWORD PTR bytes$1[rsp]
  0010d	49 8b d6	 mov	 rdx, r14
  00110	b9 0b 00 00 00	 mov	 ecx, 11
  00115	e8 00 00 00 00	 call	 ZwQuerySystemInformation

; 80   : 
; 81   : 	if (NT_SUCCESS(status))

  0011a	85 c0		 test	 eax, eax
  0011c	78 55		 js	 SHORT $LN87@ScanSectio

; 82   : 	{
; 83   : 		PRTL_PROCESS_MODULE_INFORMATION pMod = pMods->Modules;
; 84   : 
; 85   : 		for (ULONG i = 0; i < pMods->NumberOfModules; i++)

  0011e	45 8b 0e	 mov	 r9d, DWORD PTR [r14]
  00121	8b d5		 mov	 edx, ebp
  00123	45 85 c9	 test	 r9d, r9d
  00126	74 4b		 je	 SHORT $LN87@ScanSectio
  00128	49 8d 4e 20	 lea	 rcx, QWORD PTR [r14+32]
  0012c	0f 1f 40 00	 npad	 4
$LL14@ScanSectio:

; 86   : 		{
; 87   : 			// System routine is inside module
; 88   : 			if (checkPtr >= pMod[i].ImageBase &&

  00130	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  00134	49 3b d8	 cmp	 rbx, r8
  00137	72 0a		 jb	 SHORT $LN12@ScanSectio
  00139	8b 01		 mov	 eax, DWORD PTR [rcx]
  0013b	49 03 c0	 add	 rax, r8
  0013e	48 3b d8	 cmp	 rbx, rax
  00141	72 10		 jb	 SHORT $LN59@ScanSectio
$LN12@ScanSectio:

; 82   : 	{
; 83   : 		PRTL_PROCESS_MODULE_INFORMATION pMod = pMods->Modules;
; 84   : 
; 85   : 		for (ULONG i = 0; i < pMods->NumberOfModules; i++)

  00143	ff c2		 inc	 edx
  00145	48 81 c1 28 01
	00 00		 add	 rcx, 296		; 00000128H
  0014c	41 3b d1	 cmp	 edx, r9d
  0014f	72 df		 jb	 SHORT $LL14@ScanSectio
  00151	eb 20		 jmp	 SHORT $LN87@ScanSectio
$LN59@ScanSectio:

; 89   : 				checkPtr < (PVOID)((PUCHAR)pMod[i].ImageBase + pMod[i].ImageSize))
; 90   : 			{
; 91   : 				g_KernelBase = pMod[i].ImageBase;

  00153	8b c2		 mov	 eax, edx
  00155	48 69 c8 28 01
	00 00		 imul	 rcx, rax, 296		; 00000128H
  0015c	4a 8b 44 31 18	 mov	 rax, QWORD PTR [rcx+r14+24]
  00161	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?g_KernelBase@@3PEAXEA, rax ; g_KernelBase

; 92   : 				g_KernelSize = pMod[i].ImageSize;

  00168	42 8b 44 31 20	 mov	 eax, DWORD PTR [rcx+r14+32]
  0016d	89 05 00 00 00
	00		 mov	 DWORD PTR ?g_KernelSize@@3KA, eax ; g_KernelSize
$LN87@ScanSectio:

; 93   : 				if (pSize)
; 94   : 					*pSize = g_KernelSize;
; 95   : 				break;
; 96   : 			}
; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	if (pMods)

  00173	4d 85 f6	 test	 r14, r14
  00176	74 0e		 je	 SHORT $LN22@ScanSectio

; 101  : 		ExFreePoolWithTag(pMods, 0x454E4F45); // 'ENON'

  00178	ba 45 4f 4e 45	 mov	 edx, 1162760005		; 454e4f45H
  0017d	49 8b ce	 mov	 rcx, r14
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN22@ScanSectio:

; 102  : 
; 103  : 	return g_KernelBase;

  00186	4c 8b 2d 00 00
	00 00		 mov	 r13, QWORD PTR ?g_KernelBase@@3PEAXEA ; g_KernelBase

; 112  : 
; 113  : 	PVOID base = GetKernelBase(NULL);
; 114  : 	if (!base)

  0018d	4d 85 ed	 test	 r13, r13
  00190	0f 84 82 00 00
	00		 je	 $LN3@ScanSectio
$LN96@ScanSectio:

; 115  : 		return STATUS_NOT_FOUND;
; 116  : 
; 117  : 
; 118  : 	PIMAGE_NT_HEADERS64 pHdr = RtlImageNtHeader(base);

  00196	49 8b cd	 mov	 rcx, r13
  00199	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlImageNtHeader
  0019f	48 8b e8	 mov	 rbp, rax

; 119  : 	if (!pHdr)

  001a2	48 85 c0	 test	 rax, rax
  001a5	75 07		 jne	 SHORT $LN7@ScanSectio

; 120  : 		return STATUS_INVALID_IMAGE_FORMAT;

  001a7	b8 7b 00 00 c0	 mov	 eax, -1073741701	; ffffffffc000007bH
  001ac	eb 6f		 jmp	 SHORT $LN94@ScanSectio
$LN7@ScanSectio:

; 121  : 
; 122  : 	PIMAGE_SECTION_HEADER pFirstSection = (PIMAGE_SECTION_HEADER)(pHdr + 1);

  001ae	4c 8d b0 08 01
	00 00		 lea	 r14, QWORD PTR [rax+264]

; 123  : 	for (PIMAGE_SECTION_HEADER pSection = pFirstSection; pSection < pFirstSection + pHdr->FileHeader.NumberOfSections; pSection++)

  001b5	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  001b9	49 8b de	 mov	 rbx, r14
  001bc	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  001c0	49 8d 04 ce	 lea	 rax, QWORD PTR [r14+rcx*8]
  001c4	4c 3b f0	 cmp	 r14, rax
  001c7	73 4f		 jae	 SHORT $LN3@ScanSectio
  001c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@ScanSectio:

; 124  : 	{
; 125  : 		ANSI_STRING s1, s2;
; 126  : 		RtlInitAnsiString(&s1, section);

  001d0	49 8b d4	 mov	 rdx, r12
  001d3	48 8d 4c 24 48	 lea	 rcx, QWORD PTR s1$4[rsp]
  001d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitAnsiString

; 127  : 		RtlInitAnsiString(&s2, (PCCHAR)pSection->Name);

  001de	48 8b d3	 mov	 rdx, rbx
  001e1	48 8d 4c 24 38	 lea	 rcx, QWORD PTR s2$3[rsp]
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitAnsiString

; 128  : 		if (RtlCompareString(&s1, &s2, TRUE) == 0)

  001ec	41 b0 01	 mov	 r8b, 1
  001ef	48 8d 54 24 38	 lea	 rdx, QWORD PTR s2$3[rsp]
  001f4	48 8d 4c 24 48	 lea	 rcx, QWORD PTR s1$4[rsp]
  001f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCompareString
  001ff	85 c0		 test	 eax, eax
  00201	74 42		 je	 SHORT $LN60@ScanSectio

; 123  : 	for (PIMAGE_SECTION_HEADER pSection = pFirstSection; pSection < pFirstSection + pHdr->FileHeader.NumberOfSections; pSection++)

  00203	0f b7 45 06	 movzx	 eax, WORD PTR [rbp+6]
  00207	48 83 c3 28	 add	 rbx, 40			; 00000028H
  0020b	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  0020f	49 8d 04 ce	 lea	 rax, QWORD PTR [r14+rcx*8]
  00213	48 3b d8	 cmp	 rbx, rax
  00216	72 b8		 jb	 SHORT $LL4@ScanSectio
$LN3@ScanSectio:

; 136  : 		}
; 137  : 	}
; 138  : 
; 139  : 	return STATUS_NOT_FOUND;

  00218	b8 25 02 00 c0	 mov	 eax, -1073741275	; ffffffffc0000225H
$LN94@ScanSectio:
  0021d	4c 8b ac 24 a0
	00 00 00	 mov	 r13, QWORD PTR [rsp+160]
  00225	48 8b ac 24 98
	00 00 00	 mov	 rbp, QWORD PTR [rsp+152]
  0022d	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  00235	4c 8b 74 24 60	 mov	 r14, QWORD PTR [rsp+96]

; 140  : }

  0023a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0023e	41 5f		 pop	 r15
  00240	41 5c		 pop	 r12
  00242	5f		 pop	 rdi
  00243	5e		 pop	 rsi
  00244	c3		 ret	 0
$LN60@ScanSectio:

; 129  : 		{
; 130  : 			PVOID ptr = NULL;
; 131  : 			NTSTATUS status = PatternScan(pattern, wildcard, len, (PUCHAR)base + pSection->VirtualAddress, pSection->Misc.VirtualSize, &ptr);

  00245	44 8b 5b 0c	 mov	 r11d, DWORD PTR [rbx+12]
  00249	4d 03 dd	 add	 r11, r13

; 22   : 	if (ppFound == NULL || pattern == NULL || base == NULL)

  0024c	48 85 ff	 test	 rdi, rdi
  0024f	74 76		 je	 SHORT $LN50@ScanSectio
  00251	4d 85 db	 test	 r11, r11
  00254	74 71		 je	 SHORT $LN50@ScanSectio

; 129  : 		{
; 130  : 			PVOID ptr = NULL;
; 131  : 			NTSTATUS status = PatternScan(pattern, wildcard, len, (PUCHAR)base + pSection->VirtualAddress, pSection->Misc.VirtualSize, &ptr);

  00256	44 8b 4b 08	 mov	 r9d, DWORD PTR [rbx+8]

; 25   : 	for (ULONG_PTR i = 0; i < size - len; i++)

  0025a	33 ed		 xor	 ebp, ebp
  0025c	44 8b c5	 mov	 r8d, ebp
  0025f	4c 2b ce	 sub	 r9, rsi
  00262	74 57		 je	 SHORT $LN44@ScanSectio

; 129  : 		{
; 130  : 			PVOID ptr = NULL;
; 131  : 			NTSTATUS status = PatternScan(pattern, wildcard, len, (PUCHAR)base + pSection->VirtualAddress, pSection->Misc.VirtualSize, &ptr);

  00264	4d 8b d3	 mov	 r10, r11
  00267	4c 2b d7	 sub	 r10, rdi
  0026a	66 0f 1f 44 00
	00		 npad	 6
$LL45@ScanSectio:

; 28   : 		for (ULONG_PTR j = 0; j < len; j++)

  00270	48 85 f6	 test	 rsi, rsi
  00273	74 26		 je	 SHORT $LN62@ScanSectio
  00275	48 8b c7	 mov	 rax, rdi
  00278	4b 8d 14 02	 lea	 rdx, QWORD PTR [r10+r8]
  0027c	0f 1f 40 00	 npad	 4
$LL48@ScanSectio:

; 29   : 		{
; 30   : 			if (pattern[j] != wildcard && pattern[j] != ((PCUCHAR)base)[i + j])

  00280	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00283	41 3a cf	 cmp	 cl, r15b
  00286	74 05		 je	 SHORT $LN46@ScanSectio
  00288	3a 0c 02	 cmp	 cl, BYTE PTR [rdx+rax]
  0028b	75 26		 jne	 SHORT $LN61@ScanSectio
$LN46@ScanSectio:

; 26   : 	{
; 27   : 		BOOLEAN found = TRUE;
; 28   : 		for (ULONG_PTR j = 0; j < len; j++)

  0028d	48 ff c0	 inc	 rax
  00290	48 8b c8	 mov	 rcx, rax
  00293	48 2b cf	 sub	 rcx, rdi
  00296	48 3b ce	 cmp	 rcx, rsi
  00299	72 e5		 jb	 SHORT $LL48@ScanSectio
$LN62@ScanSectio:

; 132  : 			if (NT_SUCCESS(status))
; 133  : 				*(PULONG)ppFound = (ULONG)((PUCHAR)ptr - (PUCHAR)base);

  0029b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ppFound$[rsp]

; 39   : 			*ppFound = (PUCHAR)base + i;

  002a3	4b 8d 04 18	 lea	 rax, QWORD PTR [r8+r11]

; 132  : 			if (NT_SUCCESS(status))
; 133  : 				*(PULONG)ppFound = (ULONG)((PUCHAR)ptr - (PUCHAR)base);

  002a7	41 2b c5	 sub	 eax, r13d
  002aa	89 01		 mov	 DWORD PTR [rcx], eax

; 134  : 
; 135  : 			return status;

  002ac	8b c5		 mov	 eax, ebp
  002ae	e9 6a ff ff ff	 jmp	 $LN94@ScanSectio
$LN61@ScanSectio:

; 25   : 	for (ULONG_PTR i = 0; i < size - len; i++)

  002b3	49 ff c0	 inc	 r8
  002b6	4d 3b c1	 cmp	 r8, r9
  002b9	72 b5		 jb	 SHORT $LL45@ScanSectio
$LN44@ScanSectio:

; 40   : 			return STATUS_SUCCESS;
; 41   : 		}
; 42   : 	}
; 43   : 
; 44   : 	return STATUS_NOT_FOUND;

  002bb	bd 25 02 00 c0	 mov	 ebp, -1073741275	; ffffffffc0000225H

; 134  : 
; 135  : 			return status;

  002c0	8b c5		 mov	 eax, ebp
  002c2	e9 56 ff ff ff	 jmp	 $LN94@ScanSectio
$LN50@ScanSectio:

; 23   : 		return STATUS_INVALID_PARAMETER;

  002c7	bd 0d 00 00 c0	 mov	 ebp, -1073741811	; ffffffffc000000dH

; 134  : 
; 135  : 			return status;

  002cc	8b c5		 mov	 eax, ebp
  002ce	e9 4a ff ff ff	 jmp	 $LN94@ScanSectio
?ScanSection@@YAJPEADPEBEE_KPEAPEAX@Z ENDP		; ScanSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\ClearTraces\ClearPIDcache.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\km\Ntstrsafe.h
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\ClearTraces\ClearPIDcache.cpp
;	COMDAT ?GetKernelBase@@YAPEAXPEAK@Z
_TEXT	SEGMENT
routineName$ = 32
pSize$ = 64
bytes$ = 72
?GetKernelBase@@YAPEAXPEAK@Z PROC			; GetKernelBase, COMDAT

; 49   : {

$LN47:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 50   : 	NTSTATUS status = STATUS_SUCCESS;
; 51   : 	ULONG bytes = 0;

  0000f	33 db		 xor	 ebx, ebx
  00011	48 8b f1	 mov	 rsi, rcx

; 52   : 	PRTL_PROCESS_MODULES pMods = NULL;
; 53   : 	PVOID checkPtr = NULL;
; 54   : 	UNICODE_STRING routineName;
; 55   : 
; 56   : 	// Already found
; 57   : 	if (g_KernelBase != NULL)

  00014	48 39 1d 00 00
	00 00		 cmp	 QWORD PTR ?g_KernelBase@@3PEAXEA, rbx ; g_KernelBase
  0001b	89 5c 24 48	 mov	 DWORD PTR bytes$[rsp], ebx
  0001f	74 28		 je	 SHORT $LN5@GetKernelB

; 58   : 	{
; 59   : 		if (pSize)

  00021	48 85 c9	 test	 rcx, rcx
  00024	0f 84 49 01 00
	00		 je	 $LN12@GetKernelB

; 60   : 			*pSize = g_KernelSize;

  0002a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?g_KernelSize@@3KA ; g_KernelSize
  00030	89 01		 mov	 DWORD PTR [rcx], eax

; 102  : 
; 103  : 	return g_KernelBase;

  00032	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?g_KernelBase@@3PEAXEA ; g_KernelBase

; 104  : }

  00039	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0003e	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00043	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
$LN5@GetKernelB:
  00049	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\km\Ntstrsafe.h

; 12651:         status = RtlStringLengthWorkerW(pszSrc, cchMax, &cchSrcLength);

  0004c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1BG@KCECJMBN@?$AAN?$AAt?$AAO?$AAp?$AAe?$AAn?$AAF?$AAi?$AAl?$AAe@FNODOBFM@
  00053	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  00058	49 8b c0	 mov	 rax, r8
  0005b	0f 11 44 24 20	 movups	 XMMWORD PTR routineName$[rsp], xmm0
  00060	8b ca		 mov	 ecx, edx
$LL25@GetKernelB:

; 11856:     while (cchMax && (*psz != L'\0'))

  00062	66 39 18	 cmp	 WORD PTR [rax], bx
  00065	74 0c		 je	 SHORT $LN42@GetKernelB

; 11857:     {
; 11858:         psz++;

  00067	48 83 c0 02	 add	 rax, 2

; 11859:         cchMax--;

  0006b	48 83 e9 01	 sub	 rcx, 1
  0006f	75 f1		 jne	 SHORT $LL25@GetKernelB

; 11860:     }
; 11861: 
; 11862:     if (cchMax == 0)
; 11863:     {
; 11864:         // the string is longer than cchMax
; 11865:         status = STATUS_INVALID_PARAMETER;
; 11866:     }
; 11867: 
; 11868:     if (pcchLength)
; 11869:     {
; 11870:         if (NT_SUCCESS(status))

  00071	eb 19		 jmp	 SHORT $LN21@GetKernelB
$LN42@GetKernelB:

; 11871:         {
; 11872:             *pcchLength = cchOriginalMax - cchMax;

  00073	48 2b d1	 sub	 rdx, rcx

; 12665:                 DestinationString->Buffer = (PWSTR)pszSrc;

  00076	4c 89 44 24 28	 mov	 QWORD PTR routineName$[rsp+8], r8
  0007b	66 03 d2	 add	 dx, dx
  0007e	66 89 54 24 20	 mov	 WORD PTR routineName$[rsp], dx
  00083	66 83 c2 02	 add	 dx, 2
  00087	66 89 54 24 22	 mov	 WORD PTR routineName$[rsp+2], dx
$LN21@GetKernelB:
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\ClearTraces\ClearPIDcache.cpp

; 66   : 	checkPtr = MmGetSystemRoutineAddress(&routineName);

  0008c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR routineName$[rsp]
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmGetSystemRoutineAddress
  00097	48 8b f8	 mov	 rdi, rax

; 67   : 	if (checkPtr == NULL)

  0009a	48 85 c0	 test	 rax, rax
  0009d	0f 84 e7 00 00
	00		 je	 $LN43@GetKernelB

; 68   : 		return NULL;
; 69   : 
; 70   : 	
; 71   : 	status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);

  000a3	44 8b 44 24 48	 mov	 r8d, DWORD PTR bytes$[rsp]
  000a8	4c 8d 4c 24 48	 lea	 r9, QWORD PTR bytes$[rsp]
  000ad	33 d2		 xor	 edx, edx
  000af	8d 4a 0b	 lea	 ecx, QWORD PTR [rdx+11]
  000b2	e8 00 00 00 00	 call	 ZwQuerySystemInformation

; 72   : 
; 73   : 	if (bytes == 0)

  000b7	8b 44 24 48	 mov	 eax, DWORD PTR bytes$[rsp]
  000bb	85 c0		 test	 eax, eax
  000bd	0f 84 c7 00 00
	00		 je	 $LN43@GetKernelB

; 74   : 		return NULL;
; 75   : 
; 76   : 	pMods = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, 0x454E4F45); // 'ENON'

  000c3	8b d0		 mov	 edx, eax
  000c5	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  000ca	33 c9		 xor	 ecx, ecx
  000cc	41 b8 45 4f 4e
	45		 mov	 r8d, 1162760005		; 454e4f45H
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag

; 77   : 	RtlZeroMemory(pMods, bytes);

  000d8	44 8b 44 24 48	 mov	 r8d, DWORD PTR bytes$[rsp]
  000dd	33 d2		 xor	 edx, edx
  000df	48 8b c8	 mov	 rcx, rax
  000e2	4c 8b f0	 mov	 r14, rax
  000e5	e8 00 00 00 00	 call	 memset

; 78   : 
; 79   : 	status = ZwQuerySystemInformation(SystemModuleInformation, pMods, bytes, &bytes);

  000ea	44 8b 44 24 48	 mov	 r8d, DWORD PTR bytes$[rsp]
  000ef	4c 8d 4c 24 48	 lea	 r9, QWORD PTR bytes$[rsp]
  000f4	49 8b d6	 mov	 rdx, r14
  000f7	b9 0b 00 00 00	 mov	 ecx, 11
  000fc	e8 00 00 00 00	 call	 ZwQuerySystemInformation

; 80   : 
; 81   : 	if (NT_SUCCESS(status))

  00101	85 c0		 test	 eax, eax
  00103	78 56		 js	 SHORT $LN44@GetKernelB

; 82   : 	{
; 83   : 		PRTL_PROCESS_MODULE_INFORMATION pMod = pMods->Modules;
; 84   : 
; 85   : 		for (ULONG i = 0; i < pMods->NumberOfModules; i++)

  00105	45 8b 06	 mov	 r8d, DWORD PTR [r14]
  00108	45 85 c0	 test	 r8d, r8d
  0010b	74 4e		 je	 SHORT $LN44@GetKernelB
  0010d	49 8d 4e 20	 lea	 rcx, QWORD PTR [r14+32]
$LL4@GetKernelB:

; 86   : 		{
; 87   : 			// System routine is inside module
; 88   : 			if (checkPtr >= pMod[i].ImageBase &&

  00111	48 8b 51 f8	 mov	 rdx, QWORD PTR [rcx-8]
  00115	48 3b fa	 cmp	 rdi, rdx
  00118	72 0a		 jb	 SHORT $LN2@GetKernelB
  0011a	8b 01		 mov	 eax, DWORD PTR [rcx]
  0011c	48 03 c2	 add	 rax, rdx
  0011f	48 3b f8	 cmp	 rdi, rax
  00122	72 10		 jb	 SHORT $LN34@GetKernelB
$LN2@GetKernelB:

; 82   : 	{
; 83   : 		PRTL_PROCESS_MODULE_INFORMATION pMod = pMods->Modules;
; 84   : 
; 85   : 		for (ULONG i = 0; i < pMods->NumberOfModules; i++)

  00124	ff c3		 inc	 ebx
  00126	48 81 c1 28 01
	00 00		 add	 rcx, 296		; 00000128H
  0012d	41 3b d8	 cmp	 ebx, r8d
  00130	72 df		 jb	 SHORT $LL4@GetKernelB
  00132	eb 27		 jmp	 SHORT $LN44@GetKernelB
$LN34@GetKernelB:

; 89   : 				checkPtr < (PVOID)((PUCHAR)pMod[i].ImageBase + pMod[i].ImageSize))
; 90   : 			{
; 91   : 				g_KernelBase = pMod[i].ImageBase;

  00134	8b c3		 mov	 eax, ebx
  00136	48 69 c8 28 01
	00 00		 imul	 rcx, rax, 296		; 00000128H
  0013d	4a 8b 44 31 18	 mov	 rax, QWORD PTR [rcx+r14+24]
  00142	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?g_KernelBase@@3PEAXEA, rax ; g_KernelBase

; 92   : 				g_KernelSize = pMod[i].ImageSize;

  00149	42 8b 44 31 20	 mov	 eax, DWORD PTR [rcx+r14+32]
  0014e	89 05 00 00 00
	00		 mov	 DWORD PTR ?g_KernelSize@@3KA, eax ; g_KernelSize

; 93   : 				if (pSize)

  00154	48 85 f6	 test	 rsi, rsi
  00157	74 02		 je	 SHORT $LN44@GetKernelB

; 94   : 					*pSize = g_KernelSize;

  00159	89 06		 mov	 DWORD PTR [rsi], eax
$LN44@GetKernelB:

; 95   : 				break;
; 96   : 			}
; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	if (pMods)

  0015b	4d 85 f6	 test	 r14, r14
  0015e	74 0e		 je	 SHORT $LN45@GetKernelB

; 101  : 		ExFreePoolWithTag(pMods, 0x454E4F45); // 'ENON'

  00160	ba 45 4f 4e 45	 mov	 edx, 1162760005		; 454e4f45H
  00165	49 8b ce	 mov	 rcx, r14
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN45@GetKernelB:
  0016e	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]
$LN12@GetKernelB:

; 102  : 
; 103  : 	return g_KernelBase;

  00173	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?g_KernelBase@@3PEAXEA ; g_KernelBase

; 104  : }

  0017a	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0017f	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00184	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00188	5f		 pop	 rdi
  00189	c3		 ret	 0
$LN43@GetKernelB:
  0018a	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0018f	33 c0		 xor	 eax, eax
  00191	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00196	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019a	5f		 pop	 rdi
  0019b	c3		 ret	 0
?GetKernelBase@@YAPEAXPEAK@Z ENDP			; GetKernelBase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\ClearTraces\ClearPIDcache.cpp
;	COMDAT ?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z
_TEXT	SEGMENT
pattern$ = 16
wildcard$ = 24
len$ = 32
base$ = 40
size$ = 48
ppFound$ = 56
?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z PROC		; PatternScan, COMDAT

; 20   : {

$LN33:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	41 56		 push	 r14

; 21   : 	ASSERT(ppFound != NULL && pattern != NULL && base != NULL);
; 22   : 	if (ppFound == NULL || pattern == NULL || base == NULL)

  0000c	4c 8b 74 24 38	 mov	 r14, QWORD PTR ppFound$[rsp]
  00011	49 8b f1	 mov	 rsi, r9
  00014	4d 8b d8	 mov	 r11, r8
  00017	0f b6 da	 movzx	 ebx, dl
  0001a	4c 8b d1	 mov	 r10, rcx
  0001d	4d 85 f6	 test	 r14, r14
  00020	0f 84 82 00 00
	00		 je	 $LN9@PatternSca
  00026	48 85 c9	 test	 rcx, rcx
  00029	74 7d		 je	 SHORT $LN9@PatternSca
  0002b	4d 85 c9	 test	 r9, r9
  0002e	74 78		 je	 SHORT $LN9@PatternSca

; 23   : 		return STATUS_INVALID_PARAMETER;
; 24   : 
; 25   : 	for (ULONG_PTR i = 0; i < size - len; i++)

  00030	4c 8b 4c 24 30	 mov	 r9, QWORD PTR size$[rsp]
  00035	45 33 c0	 xor	 r8d, r8d
  00038	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi
  0003d	4d 2b cb	 sub	 r9, r11
  00040	74 4f		 je	 SHORT $LN3@PatternSca
  00042	48 8b fe	 mov	 rdi, rsi
  00045	48 2b f9	 sub	 rdi, rcx
$LL4@PatternSca:

; 26   : 	{
; 27   : 		BOOLEAN found = TRUE;
; 28   : 		for (ULONG_PTR j = 0; j < len; j++)

  00048	4d 85 db	 test	 r11, r11
  0004b	74 21		 je	 SHORT $LN16@PatternSca
  0004d	49 8b c2	 mov	 rax, r10
  00050	4a 8d 14 07	 lea	 rdx, QWORD PTR [rdi+r8]
$LL7@PatternSca:

; 29   : 		{
; 30   : 			if (pattern[j] != wildcard && pattern[j] != ((PCUCHAR)base)[i + j])

  00054	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00057	3a cb		 cmp	 cl, bl
  00059	74 05		 je	 SHORT $LN5@PatternSca
  0005b	3a 0c 02	 cmp	 cl, BYTE PTR [rdx+rax]
  0005e	75 29		 jne	 SHORT $LN15@PatternSca
$LN5@PatternSca:

; 26   : 	{
; 27   : 		BOOLEAN found = TRUE;
; 28   : 		for (ULONG_PTR j = 0; j < len; j++)

  00060	48 ff c0	 inc	 rax
  00063	48 8b c8	 mov	 rcx, rax
  00066	49 2b ca	 sub	 rcx, r10
  00069	49 3b cb	 cmp	 rcx, r11
  0006c	72 e6		 jb	 SHORT $LL7@PatternSca
$LN16@PatternSca:
  0006e	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]

; 31   : 			{
; 32   : 				found = FALSE;
; 33   : 				break;
; 34   : 			}
; 35   : 		}
; 36   : 
; 37   : 		if (found != FALSE)
; 38   : 		{
; 39   : 			*ppFound = (PUCHAR)base + i;

  00073	49 8d 04 30	 lea	 rax, QWORD PTR [r8+rsi]
  00077	49 89 06	 mov	 QWORD PTR [r14], rax

; 40   : 			return STATUS_SUCCESS;

  0007a	33 c0		 xor	 eax, eax

; 45   : }

  0007c	48 8b 5c 24 18	 mov	 rbx, QWORD PTR [rsp+24]
  00081	48 8b 74 24 20	 mov	 rsi, QWORD PTR [rsp+32]
  00086	41 5e		 pop	 r14
  00088	c3		 ret	 0
$LN15@PatternSca:

; 23   : 		return STATUS_INVALID_PARAMETER;
; 24   : 
; 25   : 	for (ULONG_PTR i = 0; i < size - len; i++)

  00089	49 ff c0	 inc	 r8
  0008c	4d 3b c1	 cmp	 r8, r9
  0008f	72 b7		 jb	 SHORT $LL4@PatternSca
$LN3@PatternSca:
  00091	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]

; 41   : 		}
; 42   : 	}
; 43   : 
; 44   : 	return STATUS_NOT_FOUND;

  00096	b8 25 02 00 c0	 mov	 eax, -1073741275	; ffffffffc0000225H

; 45   : }

  0009b	48 8b 5c 24 18	 mov	 rbx, QWORD PTR [rsp+24]
  000a0	48 8b 74 24 20	 mov	 rsi, QWORD PTR [rsp+32]
  000a5	41 5e		 pop	 r14
  000a7	c3		 ret	 0
$LN9@PatternSca:
  000a8	48 8b 5c 24 18	 mov	 rbx, QWORD PTR [rsp+24]
  000ad	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH
  000b2	48 8b 74 24 20	 mov	 rsi, QWORD PTR [rsp+32]
  000b7	41 5e		 pop	 r14
  000b9	c3		 ret	 0
?PatternScan@@YAJPEBEE_KPEBX1PEAPEAX@Z ENDP		; PatternScan
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\ClearTraces\ClearPIDcache.cpp
;	COMDAT ?ResolveRelativeAddress@@YAPEAXPEAXKK@Z
_TEXT	SEGMENT
Instruction$ = 8
OffsetOffset$ = 16
InstructionSize$ = 24
?ResolveRelativeAddress@@YAPEAXPEAXKK@Z PROC		; ResolveRelativeAddress, COMDAT

; 11   : 	ULONG_PTR Instr = (ULONG_PTR)Instruction;
; 12   : 	LONG RipOffset = *(PLONG)(Instr + OffsetOffset);

  00000	8b c2		 mov	 eax, edx

; 13   : 	PVOID ResolvedAddr = (PVOID)(Instr + InstructionSize + RipOffset);

  00002	48 63 14 08	 movsxd	 rdx, DWORD PTR [rax+rcx]
  00006	48 03 ca	 add	 rcx, rdx
  00009	41 8b c0	 mov	 eax, r8d
  0000c	48 03 c1	 add	 rax, rcx

; 14   : 
; 15   : 	return ResolvedAddr;
; 16   : }

  0000f	c3		 ret	 0
?ResolveRelativeAddress@@YAPEAXPEAXKK@Z ENDP		; ResolveRelativeAddress
_TEXT	ENDS
END
