; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	ExPoolZeroingNativelySupported
;	COMDAT ExPoolZeroingNativelySupported
_BSS	SEGMENT
ExPoolZeroingNativelySupported DB 01H DUP (?)
_BSS	ENDS
PUBLIC	?get_system_module_base@corefuncs@driver@@YAPEAXPEBD@Z ; driver::corefuncs::get_system_module_base
PUBLIC	?WriteToReadOnlyMemory@corefuncs@driver@@YAHPEAX0_K@Z ; driver::corefuncs::WriteToReadOnlyMemory
PUBLIC	?get_driver_objectptr@corefuncs@driver@@YAPEAU_DRIVER_OBJECT@@PEAU_UNICODE_STRING@@@Z ; driver::corefuncs::get_driver_objectptr
PUBLIC	?CallKernelFunction@hooks@driver@@YAHPEAX@Z	; driver::hooks::CallKernelFunction
PUBLIC	??_C@_1CA@KBAOBDIJ@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?2?$AAs?$AAc?$AAm?$AAb?$AAu?$AAs?$AAl@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_RtlInitUnicodeString:PROC
EXTRN	__imp_ExAllocatePoolWithTag:PROC
EXTRN	__imp_ExFreePoolWithTag:PROC
EXTRN	__imp_MmProbeAndLockPages:PROC
EXTRN	__imp_MmUnlockPages:PROC
EXTRN	__imp_MmProtectMdlSystemAddress:PROC
EXTRN	__imp_MmMapLockedPagesSpecifyCache:PROC
EXTRN	__imp_MmUnmapLockedPages:PROC
EXTRN	__imp_IoAllocateMdl:PROC
EXTRN	__imp_IoFreeMdl:PROC
EXTRN	ZwQuerySystemInformation:PROC
EXTRN	__imp_ObReferenceObjectByName:PROC
EXTRN	memcpy:PROC
EXTRN	__imp_IoDriverObjectType:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$RtlSecureZeroMemory DD imagerel $LN4
	DD	imagerel $LN4+27
	DD	imagerel $unwind$RtlSecureZeroMemory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get_system_module_base@corefuncs@driver@@YAPEAXPEBD@Z DD imagerel $LN20
	DD	imagerel $LN20+264
	DD	imagerel $unwind$?get_system_module_base@corefuncs@driver@@YAPEAXPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?WriteToReadOnlyMemory@corefuncs@driver@@YAHPEAX0_K@Z DD imagerel $LN5
	DD	imagerel $LN5+185
	DD	imagerel $unwind$?WriteToReadOnlyMemory@corefuncs@driver@@YAHPEAX0_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get_driver_objectptr@corefuncs@driver@@YAPEAU_DRIVER_OBJECT@@PEAU_UNICODE_STRING@@@Z DD imagerel $LN5
	DD	imagerel $LN5+76
	DD	imagerel $unwind$?get_driver_objectptr@corefuncs@driver@@YAPEAU_DRIVER_OBJECT@@PEAU_UNICODE_STRING@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CallKernelFunction@hooks@driver@@YAHPEAX@Z DD imagerel $LN16
	DD	imagerel $LN16+128
	DD	imagerel $unwind$?CallKernelFunction@hooks@driver@@YAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?CallKernelFunction@hooks@driver@@YAHPEAX@Z DD imagerel $LN16+128
	DD	imagerel $LN16+370
	DD	imagerel $chain$0$?CallKernelFunction@hooks@driver@@YAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?CallKernelFunction@hooks@driver@@YAHPEAX@Z DD imagerel $LN16+370
	DD	imagerel $LN16+378
	DD	imagerel $chain$1$?CallKernelFunction@hooks@driver@@YAHPEAX@Z
pdata	ENDS
;	COMDAT ??_C@_1CA@KBAOBDIJ@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?2?$AAs?$AAc?$AAm?$AAb?$AAu?$AAs?$AAl@FNODOBFM@
text$s	SEGMENT
??_C@_1CA@KBAOBDIJ@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?2?$AAs?$AAc?$AAm?$AAb?$AAu?$AAs?$AAl@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H
	DB	'\', 00H, 's', 00H, 'c', 00H, 'm', 00H, 'b', 00H, 'u', 00H, 's'
	DB	00H, 'l', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?CallKernelFunction@hooks@driver@@YAHPEAX@Z DD 020022H
	DD	06001602H
	DD	imagerel $LN16
	DD	imagerel $LN16+128
	DD	imagerel $unwind$?CallKernelFunction@hooks@driver@@YAHPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?CallKernelFunction@hooks@driver@@YAHPEAX@Z DD 040522H
	DD	06001602H
	DD	0e7405H
	DD	imagerel $LN16
	DD	imagerel $LN16+128
	DD	imagerel $unwind$?CallKernelFunction@hooks@driver@@YAHPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CallKernelFunction@hooks@driver@@YAHPEAX@Z DD 020602H
	DD	03002b206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get_driver_objectptr@corefuncs@driver@@YAPEAU_DRIVER_OBJECT@@PEAU_UNICODE_STRING@@@Z DD 040602H
	DD	06001602H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?WriteToReadOnlyMemory@corefuncs@driver@@YAHPEAX0_K@Z DD 0a1402H
	DD	06001602H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get_system_module_base@corefuncs@driver@@YAPEAXPEBD@Z DD 080f02H
	DD	06141602H
	DD	08640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlSecureZeroMemory DD 040502H
	DD	06001601H
	DD	017405H
xdata	ENDS
; Function compile flags: /Ogtp
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\Core\CoreFunctions.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\km\wdm.h
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\Core\CoreFunctions.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\km\wdm.h
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\Core\CoreFunctions.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\km\wdm.h
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\Core\CoreFunctions.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\km\wdm.h
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\Core\CoreFunctions.cpp
;	COMDAT ?CallKernelFunction@hooks@driver@@YAHPEAX@Z
_TEXT	SEGMENT
MJFuncs_original$ = 64
driver_name$ = 80
kernel_function_address$ = 112
DrvObject$1 = 120
shell_code_start$ = 120
?CallKernelFunction@hooks@driver@@YAHPEAX@Z PROC	; driver::hooks::CallKernelFunction, COMDAT

; 76   : BOOL driver::hooks::CallKernelFunction(PVOID kernel_function_address) {

$LN16:
  00000	40 53		 push	 rbx
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8b d9	 mov	 rbx, rcx

; 77   : 	
; 78   : 
; 79   : 	UNICODE_STRING driver_name;
; 80   : 	RtlInitUnicodeString(&driver_name, L"\\Driver\\scmbusl");

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@KBAOBDIJ@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?2?$AAs?$AAc?$AAm?$AAb?$AAu?$AAs?$AAl@FNODOBFM@
  00010	48 8d 4c 24 50	 lea	 rcx, QWORD PTR driver_name$[rsp]
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 69   : 	status = ObReferenceObjectByName(DriverName, 0, NULL, 0, *IoDriverObjectType, KernelMode, NULL, reinterpret_cast<PVOID*>(&DrvObject));

  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_IoDriverObjectType
  00022	48 8d 4c 24 78	 lea	 rcx, QWORD PTR DrvObject$1[rsp]
  00027	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0002c	45 33 c9	 xor	 r9d, r9d
  0002f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00038	48 8d 4c 24 50	 lea	 rcx, QWORD PTR driver_name$[rsp]
  0003d	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00042	45 33 c0	 xor	 r8d, r8d
  00045	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00048	33 d2		 xor	 edx, edx
  0004a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByName

; 70   : 
; 71   : 	if (NT_SUCCESS(status)) return DrvObject;

  00058	85 c0		 test	 eax, eax
  0005a	0f 88 12 01 00
	00		 js	 $LN14@CallKernel

; 81   : 	auto scmbusl_driver_object = driver::corefuncs::get_driver_objectptr(&driver_name);
; 82   : 		
; 83   : 	if (!scmbusl_driver_object) return FALSE;

  00060	48 8b 44 24 78	 mov	 rax, QWORD PTR DrvObject$1[rsp]
  00065	48 85 c0	 test	 rax, rax
  00068	0f 84 04 01 00
	00		 je	 $LN14@CallKernel

; 84   : 
; 85   : 	
; 86   : 	// hooking part.
; 87   : 
; 88   : 	auto Original_MJFunctions_address = scmbusl_driver_object->MajorFunction[IRP_MJ_DEVICE_CONTROL];

  0006e	4c 8b 90 e0 00
	00 00		 mov	 r10, QWORD PTR [rax+224]

; 89   : 	
; 90   : 	if (!Original_MJFunctions_address) return FALSE;

  00075	4d 85 d2	 test	 r10, r10
  00078	0f 84 f4 00 00
	00		 je	 $LN14@CallKernel
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\km\wdm.h

; 12943:     __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);

  0007e	33 c0		 xor	 eax, eax
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\Core\CoreFunctions.cpp

; 92   : 	BYTE MJFuncs_original[] = { 0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18 };

  00080	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi

; 44   : 	PMDL Mdl = IoAllocateMdl(address, size, FALSE, FALSE, NULL);

  00085	45 33 c9	 xor	 r9d, r9d

; 92   : 	BYTE MJFuncs_original[] = { 0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18 };

  00088	66 c7 44 24 4d
	24 18		 mov	 WORD PTR MJFuncs_original$[rsp+13], 6180 ; 00001824H
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\km\wdm.h

; 12943:     __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);

  0008f	48 8d 7c 24 40	 lea	 rdi, QWORD PTR MJFuncs_original$[rsp]
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\Core\CoreFunctions.cpp

; 96   : 		0x48, 0xB8 // mov rax, [xxx]

  00094	66 c7 44 24 78
	48 b8		 mov	 WORD PTR shell_code_start$[rsp], 47176 ; 0000b848H
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\km\wdm.h

; 12943:     __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);

  0009b	b9 0f 00 00 00	 mov	 ecx, 15
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\Core\CoreFunctions.cpp

; 44   : 	PMDL Mdl = IoAllocateMdl(address, size, FALSE, FALSE, NULL);

  000a0	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\km\wdm.h

; 12943:     __stosb((PUCHAR)((ULONG64)vptr), 0, cnt);

  000a9	f3 aa		 rep stosb
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\Core\CoreFunctions.cpp

; 106  : 	memcpy((PVOID)((ULONG_PTR)MJFuncs_original), &shell_code_start, sizeof(shell_code_start));

  000ab	0f b7 44 24 78	 movzx	 eax, WORD PTR shell_code_start$[rsp]

; 44   : 	PMDL Mdl = IoAllocateMdl(address, size, FALSE, FALSE, NULL);

  000b0	41 8d 51 0f	 lea	 edx, QWORD PTR [r9+15]
  000b4	49 8b ca	 mov	 rcx, r10

; 106  : 	memcpy((PVOID)((ULONG_PTR)MJFuncs_original), &shell_code_start, sizeof(shell_code_start));

  000b7	66 89 44 24 40	 mov	 WORD PTR MJFuncs_original$[rsp], ax

; 44   : 	PMDL Mdl = IoAllocateMdl(address, size, FALSE, FALSE, NULL);

  000bc	45 33 c0	 xor	 r8d, r8d

; 107  : 	uintptr_t test_address = reinterpret_cast<uintptr_t>(kernel_function_address);
; 108  : 	memcpy((PVOID)((ULONG_PTR)MJFuncs_original + sizeof(shell_code_start)), &test_address, sizeof(void*));

  000bf	48 89 5c 24 42	 mov	 QWORD PTR MJFuncs_original$[rsp+2], rbx

; 109  : 	memcpy((PVOID)((ULONG_PTR)MJFuncs_original + sizeof(shell_code_start) + sizeof(void*)), &shell_code_end, sizeof(shell_code_end));

  000c4	66 c7 44 24 4a
	ff e0		 mov	 WORD PTR MJFuncs_original$[rsp+10], 57599 ; 0000e0ffH
  000cb	c6 44 24 4c cc	 mov	 BYTE PTR MJFuncs_original$[rsp+12], 204 ; 000000ccH

; 44   : 	PMDL Mdl = IoAllocateMdl(address, size, FALSE, FALSE, NULL);

  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAllocateMdl
  000d6	48 8b d8	 mov	 rbx, rax

; 45   : 
; 46   : 	if (!Mdl)

  000d9	48 85 c0	 test	 rax, rax
  000dc	0f 84 80 00 00
	00		 je	 $LN10@CallKernel

; 47   : 		return FALSE;
; 48   : 
; 49   : 	// Locking and mapping memory with RW-rights:
; 50   : 	MmProbeAndLockPages(Mdl, KernelMode, IoReadAccess);

  000e2	45 33 c0	 xor	 r8d, r8d
  000e5	33 d2		 xor	 edx, edx
  000e7	48 8b c8	 mov	 rcx, rax
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmProbeAndLockPages

; 51   : 	PVOID Mapping = MmMapLockedPagesSpecifyCache(Mdl, KernelMode, MmNonCached, NULL, FALSE, NormalPagePriority);

  000f0	45 33 c9	 xor	 r9d, r9d
  000f3	c7 44 24 28 10
	00 00 00	 mov	 DWORD PTR [rsp+40], 16
  000fb	45 33 c0	 xor	 r8d, r8d
  000fe	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00106	33 d2		 xor	 edx, edx
  00108	48 8b cb	 mov	 rcx, rbx
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmMapLockedPagesSpecifyCache

; 52   : 	MmProtectMdlSystemAddress(Mdl, PAGE_READWRITE);

  00111	ba 04 00 00 00	 mov	 edx, 4
  00116	48 8b cb	 mov	 rcx, rbx
  00119	48 8b f8	 mov	 rdi, rax
  0011c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmProtectMdlSystemAddress

; 53   : 
; 54   : 	// Write your buffer to mapping:
; 55   : 	RtlCopyMemory(Mapping, buffer, size);

  00122	8b 4c 24 48	 mov	 ecx, DWORD PTR MJFuncs_original$[rsp+8]

; 56   : 
; 57   : 	// Resources freeing:
; 58   : 	MmUnmapLockedPages(Mapping, Mdl);

  00126	48 8b d3	 mov	 rdx, rbx
  00129	f2 0f 10 44 24
	40		 movsd	 xmm0, QWORD PTR MJFuncs_original$[rsp]
  0012f	f2 0f 11 07	 movsd	 QWORD PTR [rdi], xmm0
  00133	89 4f 08	 mov	 DWORD PTR [rdi+8], ecx
  00136	0f b7 4c 24 4c	 movzx	 ecx, WORD PTR MJFuncs_original$[rsp+12]
  0013b	66 89 4f 0c	 mov	 WORD PTR [rdi+12], cx
  0013f	0f b6 4c 24 4e	 movzx	 ecx, BYTE PTR MJFuncs_original$[rsp+14]
  00144	88 4f 0e	 mov	 BYTE PTR [rdi+14], cl
  00147	48 8b cf	 mov	 rcx, rdi
  0014a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmUnmapLockedPages

; 59   : 	MmUnlockPages(Mdl);

  00150	48 8b cb	 mov	 rcx, rbx
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmUnlockPages

; 60   : 	IoFreeMdl(Mdl);

  00159	48 8b cb	 mov	 rcx, rbx
  0015c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoFreeMdl
$LN10@CallKernel:

; 110  : 
; 111  : 
; 112  : 	driver::corefuncs::WriteToReadOnlyMemory(Original_MJFunctions_address, &MJFuncs_original, sizeof(MJFuncs_original));
; 113  : 
; 114  : 	return TRUE;

  00162	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
  00167	b8 01 00 00 00	 mov	 eax, 1

; 115  : }

  0016c	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00170	5b		 pop	 rbx
  00171	c3		 ret	 0
$LN14@CallKernel:

; 89   : 	
; 90   : 	if (!Original_MJFunctions_address) return FALSE;

  00172	33 c0		 xor	 eax, eax

; 115  : }

  00174	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00178	5b		 pop	 rbx
  00179	c3		 ret	 0
?CallKernelFunction@hooks@driver@@YAHPEAX@Z ENDP	; driver::hooks::CallKernelFunction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\Core\CoreFunctions.cpp
;	COMDAT ?get_driver_objectptr@corefuncs@driver@@YAPEAU_DRIVER_OBJECT@@PEAU_UNICODE_STRING@@@Z
_TEXT	SEGMENT
DriverName$ = 80
DrvObject$ = 88
?get_driver_objectptr@corefuncs@driver@@YAPEAU_DRIVER_OBJECT@@PEAU_UNICODE_STRING@@@Z PROC ; driver::corefuncs::get_driver_objectptr, COMDAT

; 65   : PDRIVER_OBJECT driver::corefuncs::get_driver_objectptr(PUNICODE_STRING DriverName) {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 66   : 	PDRIVER_OBJECT DrvObject;
; 67   : 	NTSTATUS status = STATUS_SUCCESS;
; 68   : 
; 69   : 	status = ObReferenceObjectByName(DriverName, 0, NULL, 0, *IoDriverObjectType, KernelMode, NULL, reinterpret_cast<PVOID*>(&DrvObject));

  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_IoDriverObjectType
  0000d	48 8d 54 24 58	 lea	 rdx, QWORD PTR DrvObject$[rsp]
  00012	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  00017	33 db		 xor	 ebx, ebx
  00019	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0001e	45 33 c9	 xor	 r9d, r9d
  00021	88 5c 24 28	 mov	 BYTE PTR [rsp+40], bl
  00025	45 33 c0	 xor	 r8d, r8d
  00028	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002b	33 d2		 xor	 edx, edx
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByName

; 70   : 
; 71   : 	if (NT_SUCCESS(status)) return DrvObject;

  0003b	85 c0		 test	 eax, eax
  0003d	48 0f 49 5c 24
	58		 cmovns	 rbx, QWORD PTR DrvObject$[rsp]
  00043	48 8b c3	 mov	 rax, rbx

; 72   : 
; 73   : 	return NULL;
; 74   : }

  00046	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0004a	5b		 pop	 rbx
  0004b	c3		 ret	 0
?get_driver_objectptr@corefuncs@driver@@YAPEAU_DRIVER_OBJECT@@PEAU_UNICODE_STRING@@@Z ENDP ; driver::corefuncs::get_driver_objectptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\Core\CoreFunctions.cpp
;	COMDAT ?WriteToReadOnlyMemory@corefuncs@driver@@YAHPEAX0_K@Z
_TEXT	SEGMENT
address$ = 64
buffer$ = 72
size$ = 80
?WriteToReadOnlyMemory@corefuncs@driver@@YAHPEAX0_K@Z PROC ; driver::corefuncs::WriteToReadOnlyMemory, COMDAT

; 42   : BOOL driver::corefuncs::WriteToReadOnlyMemory(void* address, void* buffer, size_t size) {

$LN5:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	49 8b f0	 mov	 rsi, r8
  00017	48 8b ea	 mov	 rbp, rdx

; 43   : 
; 44   : 	PMDL Mdl = IoAllocateMdl(address, size, FALSE, FALSE, NULL);

  0001a	33 db		 xor	 ebx, ebx
  0001c	8b d6		 mov	 edx, esi
  0001e	45 33 c9	 xor	 r9d, r9d
  00021	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00026	45 33 c0	 xor	 r8d, r8d
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoAllocateMdl
  0002f	48 8b f8	 mov	 rdi, rax

; 45   : 
; 46   : 	if (!Mdl)

  00032	48 85 c0	 test	 rax, rax
  00035	74 6d		 je	 SHORT $LN1@WriteToRea
$LN2@WriteToRea:

; 47   : 		return FALSE;
; 48   : 
; 49   : 	// Locking and mapping memory with RW-rights:
; 50   : 	MmProbeAndLockPages(Mdl, KernelMode, IoReadAccess);

  00037	45 33 c0	 xor	 r8d, r8d
  0003a	33 d2		 xor	 edx, edx
  0003c	48 8b cf	 mov	 rcx, rdi
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmProbeAndLockPages

; 51   : 	PVOID Mapping = MmMapLockedPagesSpecifyCache(Mdl, KernelMode, MmNonCached, NULL, FALSE, NormalPagePriority);

  00045	45 33 c9	 xor	 r9d, r9d
  00048	c7 44 24 28 10
	00 00 00	 mov	 DWORD PTR [rsp+40], 16
  00050	45 33 c0	 xor	 r8d, r8d
  00053	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  00057	33 d2		 xor	 edx, edx
  00059	48 8b cf	 mov	 rcx, rdi
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmMapLockedPagesSpecifyCache

; 52   : 	MmProtectMdlSystemAddress(Mdl, PAGE_READWRITE);

  00062	ba 04 00 00 00	 mov	 edx, 4
  00067	48 8b cf	 mov	 rcx, rdi
  0006a	48 8b d8	 mov	 rbx, rax
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmProtectMdlSystemAddress

; 53   : 
; 54   : 	// Write your buffer to mapping:
; 55   : 	RtlCopyMemory(Mapping, buffer, size);

  00073	4c 8b c6	 mov	 r8, rsi
  00076	48 8b d5	 mov	 rdx, rbp
  00079	48 8b cb	 mov	 rcx, rbx
  0007c	e8 00 00 00 00	 call	 memcpy

; 56   : 
; 57   : 	// Resources freeing:
; 58   : 	MmUnmapLockedPages(Mapping, Mdl);

  00081	48 8b d7	 mov	 rdx, rdi
  00084	48 8b cb	 mov	 rcx, rbx
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmUnmapLockedPages

; 59   : 	MmUnlockPages(Mdl);

  0008d	48 8b cf	 mov	 rcx, rdi
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmUnlockPages

; 60   : 	IoFreeMdl(Mdl);

  00096	48 8b cf	 mov	 rcx, rdi
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoFreeMdl

; 61   : 
; 62   : 	return TRUE;

  0009f	b8 01 00 00 00	 mov	 eax, 1
$LN1@WriteToRea:

; 63   : }

  000a4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a9	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000ae	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000b3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
?WriteToReadOnlyMemory@corefuncs@driver@@YAHPEAX0_K@Z ENDP ; driver::corefuncs::WriteToReadOnlyMemory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\jorda\Desktop\driverx00_source\driverx00\driverx00\Core\CoreFunctions.cpp
;	COMDAT ?get_system_module_base@corefuncs@driver@@YAPEAXPEBD@Z
_TEXT	SEGMENT
module_name$ = 48
bytes$ = 56
?get_system_module_base@corefuncs@driver@@YAPEAXPEBD@Z PROC ; driver::corefuncs::get_system_module_base, COMDAT

; 3    : PVOID driver::corefuncs::get_system_module_base(const char* module_name) {

$LN20:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4    : 
; 5    : 	ULONG bytes = 0;

  0000f	33 db		 xor	 ebx, ebx

; 6    : 	NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);

  00011	4c 8d 4c 24 38	 lea	 r9, QWORD PTR bytes$[rsp]
  00016	48 8b f1	 mov	 rsi, rcx
  00019	89 5c 24 38	 mov	 DWORD PTR bytes$[rsp], ebx
  0001d	45 33 c0	 xor	 r8d, r8d
  00020	33 d2		 xor	 edx, edx
  00022	8d 4b 0b	 lea	 ecx, QWORD PTR [rbx+11]
  00025	e8 00 00 00 00	 call	 ZwQuerySystemInformation

; 7    : 
; 8    : 	if (!bytes)

  0002a	8b 44 24 38	 mov	 eax, DWORD PTR bytes$[rsp]
  0002e	85 c0		 test	 eax, eax
  00030	0f 84 c0 00 00
	00		 je	 $LN16@get_system

; 9    : 		return 0;
; 10   : 
; 11   : 
; 12   : 	PRTL_PROCESS_MODULES modules = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, 0x454E4F45); // 'ENON'

  00036	8b d0		 mov	 edx, eax
  00038	33 c9		 xor	 ecx, ecx
  0003a	41 b8 45 4f 4e
	45		 mov	 r8d, 1162760005		; 454e4f45H
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag

; 13   : 
; 14   : 	status = ZwQuerySystemInformation(SystemModuleInformation, modules, bytes, &bytes);

  00046	44 8b 44 24 38	 mov	 r8d, DWORD PTR bytes$[rsp]
  0004b	4c 8d 4c 24 38	 lea	 r9, QWORD PTR bytes$[rsp]
  00050	48 8b d0	 mov	 rdx, rax
  00053	8d 4b 0b	 lea	 ecx, QWORD PTR [rbx+11]
  00056	48 8b f8	 mov	 rdi, rax
  00059	e8 00 00 00 00	 call	 ZwQuerySystemInformation

; 15   : 
; 16   : 	if (!NT_SUCCESS(status))

  0005e	85 c0		 test	 eax, eax
  00060	0f 88 90 00 00
	00		 js	 $LN16@get_system

; 17   : 		return 0;
; 18   : 
; 19   : 
; 20   : 	PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules;

  00066	0f ae e8	 lfence

; 21   : 	PVOID module_base = 0, module_size = 0;
; 22   : 
; 23   : 	for (ULONG i = 0; i < modules->NumberOfModules; i++)

  00069	44 8b 1f	 mov	 r11d, DWORD PTR [rdi]
  0006c	44 8b cb	 mov	 r9d, ebx
  0006f	45 85 db	 test	 r11d, r11d
  00072	74 59		 je	 SHORT $LN3@get_system
  00074	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@get_system:

; 24   : 	{
; 25   : 		if (strcmp(reinterpret_cast<char*>(module[i].FullPathName), module_name) == 0)

  00080	45 8b d1	 mov	 r10d, r9d
  00083	4c 8b c6	 mov	 r8, rsi
  00086	49 69 c2 28 01
	00 00		 imul	 rax, r10, 296		; 00000128H
  0008d	48 83 c0 30	 add	 rax, 48			; 00000030H
  00091	48 03 c7	 add	 rax, rdi
  00094	4c 2b c0	 sub	 r8, rax
  00097	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL17@get_system:
  000a0	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  000a3	42 0f b6 0c 00	 movzx	 ecx, BYTE PTR [rax+r8]
  000a8	2b d1		 sub	 edx, ecx
  000aa	75 07		 jne	 SHORT $LN18@get_system
  000ac	48 ff c0	 inc	 rax
  000af	85 c9		 test	 ecx, ecx
  000b1	75 ed		 jne	 SHORT $LL17@get_system
$LN18@get_system:
  000b3	85 d2		 test	 edx, edx
  000b5	74 0a		 je	 SHORT $LN12@get_system

; 21   : 	PVOID module_base = 0, module_size = 0;
; 22   : 
; 23   : 	for (ULONG i = 0; i < modules->NumberOfModules; i++)

  000b7	41 ff c1	 inc	 r9d
  000ba	45 3b cb	 cmp	 r9d, r11d
  000bd	72 c1		 jb	 SHORT $LL4@get_system

; 24   : 	{
; 25   : 		if (strcmp(reinterpret_cast<char*>(module[i].FullPathName), module_name) == 0)

  000bf	eb 0c		 jmp	 SHORT $LN3@get_system
$LN12@get_system:

; 26   : 		{
; 27   : 			module_base = module[i].ImageBase;

  000c1	49 69 c2 28 01
	00 00		 imul	 rax, r10, 296		; 00000128H
  000c8	48 8b 5c 38 18	 mov	 rbx, QWORD PTR [rax+rdi+24]
$LN3@get_system:

; 28   : 			module_size = reinterpret_cast<PVOID>(module[i].ImageSize);
; 29   : 			break;
; 30   : 		}
; 31   : 	}
; 32   : 
; 33   : 	if (modules)
; 34   : 		ExFreePoolWithTag(modules, 0);

  000cd	0f ae e8	 lfence
  000d0	33 d2		 xor	 edx, edx
  000d2	48 8b cf	 mov	 rcx, rdi
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 35   : 
; 36   : 	if (module_base <= 0)

  000db	48 85 db	 test	 rbx, rbx
  000de	74 16		 je	 SHORT $LN16@get_system

; 37   : 		return 0;
; 38   : 
; 39   : 	return module_base;

  000e0	0f ae e8	 lfence
  000e3	48 8b c3	 mov	 rax, rbx

; 40   : }

  000e6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000eb	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000f0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f4	5f		 pop	 rdi
  000f5	c3		 ret	 0
$LN16@get_system:
  000f6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000fb	33 c0		 xor	 eax, eax
  000fd	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00102	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00106	5f		 pop	 rdi
  00107	c3		 ret	 0
?get_system_module_base@corefuncs@driver@@YAPEAXPEBD@Z ENDP ; driver::corefuncs::get_system_module_base
_TEXT	ENDS
END
